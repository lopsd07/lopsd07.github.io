# Spring Cloud Feign

JAVA 项目中接口调用有以下几种方式

1. Httpclient

HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 Http 协议的客户端编程工具包，并且它支持 HTTP 协议最新版本和建议。

HttpClient 相比传统 JDK 自带的 URLConnection，提升了易用性和灵活性，使客户端发送 HTTP 请求变得容易，提高了开发的效率。

2. Okhttp

一个处理网络请求的开源项目，是安卓端最火的轻量级框架，由 Square 公司贡献，用于替代 HttpUrlConnection 和 Apache HttpClient。OkHttp 拥有简洁的 API、高效的性能，并支持多种协议（HTTP/2 和 SPDY）。

3. HttpURLConnection

HttpURLConnection 是 Java 的标准类，它继承自 URLConnection，可用于向指定网站发送 GET 请求、POST 请求。HttpURLConnection 使用比较复杂，不像 HttpClient 那样容易使用。

4. RestTemplate

RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 HTTP 服务的方法，能够大大提高客户端的编写效率。

上面介绍的是最常见的几种调用接口的方法，我们下面要介绍的方法比上面的更简单、方便，它就是 Feign。

Feign 是一个声明式的 REST 客户端，它能让 REST 调用更加简单。Feign 供了 HTTP 请求的模板，通过编写简单的接口和插入注解，就可以定义好 HTTP 请求的参数、格式、地址等信息。

而 Feign 则会完全代理 HTTP 请求，我们只需要像调用方法一样调用它就可以完成服务请求及相关处理。

Spring Cloud 对 Feign 进行了封装，使其支持 SpringMVC 标准注解和 HttpMessageConverters。Feign 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡。

## 在Spring Cloud中集成Feign

在 Spring Cloud 中集成 Feign 的步骤相当简单，首先还是加入 Feign 的依赖，代码如下所示。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

在启动类上加 `@EnableFeignClients` 注解，如果你的 Feign 接口定义跟你的启动类不在同一个包名下，还需要制定扫描的包名 `@EnableFeignClients（basePackages=“com.xxx.api.client”）`，代码如下所示。

```java
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients(basePackages = "com.xxx.api.client")
public class FshSubstitutionServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(FshSubstitutionServiceApplication.class, args);
    }
}
```

## 使用Feign调用接口

定义一个 Feign 的客户端，以接口形式存在，代码如下所示。

```java
@FeignClient(value = "eureka-client-user-service")
public interface UserRemoteClient {
    @GetMapping("/user/hello")
    String hello();
}
```

首先我们来看接口上加的 @FeignClient 注解。这个注解标识当前是一个 Feign 的客户端，value 属性是对应的服务名称，也就是你需要调用哪个服务中的接口。

定义方法时直接复制接口的定义即可，当然还有另一种做法，就是将接口单独抽出来定义，然后在 Controller 中实现接口。

在调用的客户端中也实现了接口，从而达到接口共用的目的。我这里的做法是不共用的，即单独创建一个 API Client 的公共项目，基于约定的模式，每写一个接口就要对应写一个调用的 Client，后面打成公共的 jar，这样无论是哪个项目需要调用接口，只要引入公共的接口 SDK jar 即可，不用重新定义一遍了。

定义之后可以直接通过注入 UserRemoteClient 来调用，这对于开发人员来说就像调用本地方法一样。

接下来采用 Feign 来调用 /user/hello 接口，代码如下所示。

```java
@Autowired
private UserRemoteClient userRemoteClient;
@GetMapping("/callHello")
public String callHello() {
    //return restTemplate.getForObject("http://localhost:8083/house/hello",String.class);
    //String result = restTemplate.getForObject("http://eureka-client-user-service/user/hello",String.class);
    String result = userRemoteClient.hello();
    System.out.println("调用结果：" + result);
    return result;
}
```

通过跟注释掉的代码相比可以发现，我们的调用方式变得越来越简单了，从最开始的指定地址，到后面通过 Eureka 中的服务名称来调用，再到现在直接通过定义接口来调用。

## Spring Cloud Feign的自定义配置及使用

Feign 提供了很多的扩展机制，让用户可以更加灵活的使用，这节我们来学习 Feign 的一些自定义配置。

## 日志配置

有时候我们遇到 Bug，比如接口调用失败、参数没收到等问题，或者想看看调用性能，就需要配置 Feign 的日志了，以此让 Feign 把请求信息输出来。

首先定义一个配置类，代码如下所示。

```java
@Configuration
public class FeignConfiguration {
    /**
     * 日志级别
     *
     * @return
     */
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}
```

通过源码可以看到日志等级有 4 种，分别是：

- NONE：不输出日志。
- BASIC：只输出请求方法的 URL 和响应的状态码以及接口执行的时间。
- HEADERS：将 BASIC 信息和请求头信息输出。
- FULL：输出完整的请求信息。

配置类建好后，我们需要在 Feign Client 中的 @FeignClient 注解中指定使用的配置类，代码如下所示。

```java
@FeignClient(value = "eureka-client-user-service", configuration = FeignConfiguration. class)
public interface UserRemoteClient {
    // ...
}
```

在配置文件中执行 Client 的日志级别才能正常输出日志，格式是“logging.level.client 类地址=级别”。

```properties
logging.level.net.biancheng.feign_demo.remote.UserRemoteClient=DEBUG
```

最后通过 Feign 调用我们的 /user/hello 接口，就可以看到控制台输出的调用信息。

## 契约配置

Spring Cloud 在 Feign 的基础上做了扩展，可以让 Feign 支持 Spring MVC 的注解来调用。原生的 Feign 是不支持 Spring MVC 注解的，原生的使用方法我们在后面会讲解。

如果你想在 Spring Cloud 中使用原生的注解方式来定义客户端也是可以的，通过配置契约来改变这个配置，Spring Cloud 中默认的是 SpringMvcContract，代码如下所示。

```java
@Configuration
public class FeignConfiguration {
    @Bean
    public Contract feignContract() {
        return new feign.Contract.Default();
    }
}
```

当你配置使用默认的契约后，之前定义的 Client 就用不了，之前上面的注解是 Spring MVC 的注解。

## Basic 认证配置

通常我们调用的接口都是有权限控制的，很多时候可能认证的值是通过参数去传递的，还有就是通过请求头去传递认证信息，比如 Basic 认证方式。在 Feign 中我们可以直接配置 Basic 认证，代码如下所示。

```java
@Configuration
public class FeignConfiguration {
    @Bean
    public BasicAuthRequestInterceptor basicAuthRequestInterceptor() {
        return new BasicAuthRequestInterceptor("user", "password");
    }
}
```

或者你可以自定义属于自己的认证方式，其实就是自定义一个请求拦截器。在请求之前做认证操作，然后往请求头中设置认证之后的信息。通过实现 RequestInterceptor 接口来自定义认证方式，代码如下所示。

```java
public class FeignBasicAuthRequestInterceptor implements RequestInterceptor {
    public FeignBasicAuthRequestInterceptor() {
    }
    @Override
    public void apply(RequestTemplate template) {
        // 业务逻辑
    }
}
```

然后将配置改成我们自定义的就可以了，这样当 Feign 去请求接口的时候，每次请求之前都会进入 FeignBasicAuthRequestInterceptor 的 apply 方法中，在里面就可以做属于你的逻辑了，代码如下所示。

```java
@Configuration
public class FeignConfiguration {
    @Bean
    public FeignBasicAuthRequestInterceptor basicAuthRequestInterceptor() {
        return new FeignBasicAuthRequestInterceptor();
    }
}
```

## 超时时间配置

通过 Options 可以配置连接超时时间和读取超时时间（代码如下所示），Options 的第一个参数是连接超时时间（ms），默认值是 10×1000；第二个是取超时时间（ms），默认值是 60×1000。

```java
@Configuration
public class FeignConfiguration {
    @Bean
    public Request.Options options() {
        return new Request.Options(5000, 10000);
    }
}
```

## 客户端组件配置

Feign 中默认使用 JDK 原生的 URLConnection 发送 HTTP 请求，我们可以集成别的组件来替换掉 URLConnection，比如 Apache HttpClient，OkHttp。

配置 OkHttp 只需要加入 OkHttp 的依赖，代码如下所示。

```xm
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-okhttp</artifactId>
</dependency>
```

然后修改配置，将 Feign 的 HttpClient 禁用，启用 OkHttp，配置如下：

```properties
#feign 使用 okhttp
feign.httpclient.enabled=false
feign.okhttp.enabled=true
```

关于配置可参考源码 org.springframework.cloud.openfeign.FeignAutoConfiguration。
HttpClient 自动配置源码如下所示：

```java
@Configuration
@ConditionalOnClass(ApacheHttpClient.class)
@ConditionalOnMissingClass("com.netflix.loadbalancer.ILoadBalancer")
@ConditionalOnProperty(value = "feign.httpclient.enabled", matchIfMissing = true)
protected static class HttpClientFeignConfiguration {
    @Autowired(required = false)
    private HttpClient httpClient;
    @Bean
    @ConditionalOnMissingBean(Client.class)
    public Client feignClient() {
        if (this.httpClient != null) {
            return new ApacheHttpClient(this.httpClient);
        }
        return new ApacheHttpClient();
    }
}
```

OkHttp 自动配置源码如下所示：

```java
@Configuration
@ConditionalOnClass(OkHttpClient.class)
@ConditionalOnMissingClass("com.netflix.loadbalancer.ILoadBalancer")
@ConditionalOnProperty(value = "feign.okhttp.enabled", matchIfMissing = true)
protected static class OkHttpFeignConfiguration {
    @Autowired(required = false)
    private okhttp3.OkHttpClient okHttpClient;
    @Bean
    @ConditionalOnMissingBean(Client.class)
    public Client feignClient() {
        if (this.okHttpClient != null) {
            return new OkHttpClient(this.okHttpClient);
        }
        return new OkHttpClient();
    }
}
```

上面所示两段代码分别是配置 HttpClient 和 OkHttp 的方法。其通过 @ConditionalOnProperty 中的值来决定启用哪种客户端（HttpClient 和 OkHttp），@ConditionalOnClass 表示对应的类在 classpath 目录下存在时，才会去解析对应的配置文件。

## GZIP 压缩配置

开启压缩可以有效节约网络资源，提升接口性能，我们可以配置 GZIP 来压缩数据：

```properties
feign.compression.request.enabled=true
feign.compression.response.enabled=true

# 还可以配置压缩的类型、最小压缩值的标准：
feign.compression.request.mime-types=text/xml,application/xml,application/json
feign.compression.request.min-request-size=2048
```

只有当 Feign 的 Http Client 不是 okhttp3 的时候，压缩才会生效，配置源码在 org.spring-framework.cloud.openfeign.encoding.FeignAcceptGzipEncodingAutoConfiguration，代码如下所示。

```java
@Configuration
@EnableConfigurationProperties(FeignClientEncodingProperties.class)
@ConditionalOnClass(Feign.class)
@ConditionalOnBean(Client.class)
@ConditionalOnProperty(value = "feign.compression.response.enabled", matchIfMissing = false)
@ConditionalOnMissingBean(type = "okhttp3.OkHttpClient")
@AutoConfigureAfter(FeignAutoConfiguration.class)
public class FeignAcceptGzipEncodingAutoConfiguration {
    @Bean
    public FeignAcceptGzipEncodingInterceptor feignAcceptGzipEncodingInterceptor(
            FeignClientEncodingProperties properties) {
        return new FeignAcceptGzipEncodingInterceptor(properties);
    }
}
```

核心代码就是 @ConditionalOnMissingBean（type="okhttp3.OkHttpClient"），表示 Spring BeanFactory 中不包含指定的 bean 时条件匹配，也就是没有启用 okhttp3 时才会进行压缩配置。

## 编码器解码器配置

Feign 中提供了自定义的编码解码器设置，同时也提供了多种编码器的实现，比如 Gson、Jaxb、Jackson。我们可以用不同的编码解码器来处理数据的传输。如果你想传输 XML 格式的数据，可以自定义 XML 编码解码器来实现获取使用官方提供的 Jaxb。

配置编码解码器只需要在 Feign 的配置类中注册 Decoder 和 Encoder 这两个类即可，代码如下所示。

```java
@Bean
public Decoder decoder() {
    return new MyDecoder();
}
@Bean
public Encoder encoder() {
    return new MyEncoder();
}
```

## 使用配置自定义 Feign 的配置

除了使用代码的方式来对 Feign 进行配置，我们还可以通过配置文件的方式来指定 Feign 的配置。

```properties
# 链接超时时间
feign.client.config.feignName.connectTimeout=5000
# 读取超时时间
feign.client.config.feignName.readTimeout=5000
# 日志等级
feign.client.config.feignName.loggerLevel=full
# 重试
feign.client.config.feignName.retryer=com.example.SimpleRetryer
# 拦截器
feign.client.config.feignName.requestInterceptors[0]=com.example.FooRequestInterceptor
feign.client.config.feignName.requestInterceptors[1]=com.example.BarRequestInterceptor
# 编码器
feign.client.config.feignName.encoder=com.example.SimpleEncoder
# 解码器
feign.client.config.feignName.decoder=com.example.SimpleDecoder
# 契约
feign.client.config.feignName.contract=com.example.SimpleContract
```

## 继承特性

Feign 的继承特性可以让服务的接口定义单独抽出来，作为公共的依赖，以方便使用。

创建一个 [Maven](http://c.biancheng.net/maven/) 项目 feign-inherit-api，用于存放 API 接口的定义，增加 Feign 的依赖，代码如下所示。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

定义接口，指定服务名称，代码如下所示。

```java
@FeignClient("feign-inherit-provide")
public interface UserRemoteClient {
    @GetMapping("/user/name")
    String getName();
}
```

创建一个服务提供者 feign-inherit-provide，引入 feign-inherit-api，代码如下所示。

```xml
<dependency>
    <groupId>net.biancheng</groupId>
    <artifactId>feign-inherit-api</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</dependency>
```

实现 UserRemoteClient 接口，代码如下所示。

```java
@RestController
public class DemoController implements UserRemoteClient {
    @Override
    public String getName() {
        return "zhangsan";
    }
}
```

创建一个服务消费者 feign-inherit-consume，同样需要引入 feign-inherit-api 用于调用 feign-inherit-provide 提供的 /user/name 接口，代码如下所示。

```java
@RestController
public class DemoController {
    @Autowired
    private UserRemoteClient userRemoteClient;
    @GetMapping("/call")
    public String callHello() {
        String result = userRemoteClient.getName();
        System.out.println("getName调用结果：" + result);
    }
}
```

通过将接口的定义单独抽出来，服务提供方去实现接口，服务消费方直接就可以引入定义好的接口进行调用，非常方便。

## 多参数请求构造

多参数请求构造分为 GET 请求和 POST 请求两种方式，首先来看 GET 请求的多参数请求构造方式，代码如下所示。

```java
@GetMapping("/user/info")
String getUserInfo(@RequestParam("name")String name,@RequestParam("age")int age);
```

另一种是通过 Map 来传递多个参数，参数数量可以动态改变，笔者在这里还是推荐大家用固定的参数方式，不要用 Map 来传递参数，Map 传递参数最大的问题是可以随意传参。代码如下所示。

```java
@GetMapping("/user/detail")
String getUserDetail(@RequestParam Map<String, Object> param);
```

POST 请求多参数就定义一个参数类，通过 @RequestBody 注解的方式来实现，代码如下所示。

```java
@PostMapping("/user/add")
String addUser(@RequestBody User user);
```

实现类中也需要加上 @RequestBody 注解，代码如下所示。

```java
@RestController
public class DemoController implements UserRemoteClient {
    @Override
    public String addUser(@RequestBody User user) {
        return user.getName();
    }
}
```

## Spring Cloud Feign整合Hystrix实现容错处理

创建一个新的 Maven 项目 hystrix-feign-demo，增加 EurekaClient，Feign，Hystrix 的依赖，然后在属性文件中开启 Feign 对 Hystrix 的支持：

```properties
feign.hystrix.enabled=true
```

### Fallback 方式

在 Feign 的客户端类上的 @FeignClient 注解中指定 fallback 进行回退（代码如下所示），创建一个 Feign 的客户端类 UserRemoteClient，为其配置 fallback。

```java
@FeignClient (value = "eureka-client-user-service", fallback = UserRemoteClientFallback.class)
public interface UserRemoteClient {
    @GetMapping("/user/hello")
    String hello();
}
```

UserRemoteClientFallback 类需要实现 UserRemoteClient 类中所有的方法，返回回退时的内容，代码如下所示。

```java
@Component
public class UserRemoteClientFallback implements UserRemoteClient {
    @Override
    public String hello() {
        return "fail";
    }
}
```

停掉所有 eureka-client-user-service 服务，然后访问 /callHello 接口，这个时候 eureka-client-user-service 服务是不可用的，必然会触发回退，返回的内容是 fail 字符串，这证明回退生效了。

在这种情况下，如果你的接口调用了多个服务的接口，那么只有 eureka-client-user-service 服务会没数据，不会影响别的服务，如果不用 Hystrix 回退处理，整个请求都将失败。

```json
{
  code:200,
  message:"",
  data:{
    id:1,
    money:100.12,
    name:"fail"
  }
}
```

下面我们将启用 Hystrix 断路器禁用：

```properties
feign.hystrix.enabled=false
```

再次访问 /callHello 可以看到返回的就是 500 错误信息了，整个请求失败。

### FallbackFactory 方式

通过 fallback 已经可以实现服务不可用时回退的功能，如果你想知道触发回退的原因，可以使用 FallbackFactory 来实现回退功能，代码如下所示。

```java
@Component
public class UserRemoteClientFallbackFactory implements FallbackFactory<UserRemoteClient> {
    private Logger logger = LoggerFactory.getLogger(UserRemoteClientFallbackFactory.class);
    @Override
    public UserRemoteClient create(final Throwable cause) {
        logger.error("UserRemoteClient回退：", cause);
        return new UserRemoteClient() {
            @Override
            public String hello() {
                return "fail";
            }
        };
    }
}
```

FallbackFactory 的使用就是在 @FeignClient 中用 fallbackFactory 指定回退处理类，代码如下所示。

```java
@FeignClient(value = "eureka-client-user-service", configuration = FeignConfiguration.class, fallbackFactory = UserRemoteClientFallbackFactory.class)
```

笔者在这个回退处理的时候，将异常信息通过日志输出了，我们重新调用接口，可以看到异常信息在开发工具的控制台中输出了，FallbackFactory 和 Fallback 唯一的区别就在这里。

## Feign 中禁用 Hystrix

禁用 Hystrix 还是比较简单的，目前有两种方式可以禁用，一种是在属性文件中进行全部禁用，默认就是禁用的状态。

```properties
feign.hystrix.enabled=false
```

另一种是通过代码的方式禁用某个客户端，在 Feign 的配置类中增加如下所示的代码。

```java
@Configuration
public class FeignConfiguration {
    @Bean 
    @Scope("prototype")
    public Feign.Builder feignBuilder() {
        return Feign.builder();
    }
}
```

